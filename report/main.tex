\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{margin=2.5cm}

\title{Kryptografia stosowana: Szyfrowanie RSA i bezpieczna komunikacja}
\author{MichaÅ‚ ZduÅ„czyk \and Daniel Wybranowski \and Mateusz Hutorowicz}
\date{}

\begin{document}
\maketitle

% =========================
\section{WstÄ™p}
% (a)
% =========================

Wprowadzenie â€” PrzeglÄ…d RSA i cele kryptograficzne projektu

Celem projektu byÅ‚o zaprojektowanie oraz implementacja kryptosystemu RSA, ktÃ³ry jest jednym z najwaÅ¼niejszych i najczÄ™Å›ciej stosowanych algorytmÃ³w kryptografii asymetrycznej. Algorytm RSA umoÅ¼liwia bezpieczne przesyÅ‚anie informacji przez niezabezpieczony kanaÅ‚ komunikacyjny bez koniecznoÅ›ci wczeÅ›niejszego wspÃ³Å‚dzielenia tajnego klucza miÄ™dzy stronami.

GÅ‚Ã³wnym problemem rozwiÄ…zywanym w projekcie byÅ‚o bezpieczne przesÅ‚anie wiadomoÅ›ci przez niezaufane Å›rodowisko komunikacyjne przy uÅ¼yciu zaimplementowanego systemu szyfrowania. RozwiÄ…zanie polega na wygenerowaniu pary kluczy â€” publicznego i prywatnego â€” gdzie klucz publiczny sÅ‚uÅ¼y do szyfrowania danych, a klucz prywatny do ich odszyfrowania.

W ramach projektu zaimplementowano mechanizm generowania kluczy, proces szyfrowania oraz odszyfrowania wiadomoÅ›ci. Implementacja pokazuje, jak matematyczne podstawy kryptografii mogÄ… zostaÄ‡ przeÅ‚oÅ¼one na dziaÅ‚ajÄ…cy system informatyczny. Projekt ma rÃ³wnieÅ¼ na celu zrozumienie rÃ³Å¼nicy miÄ™dzy kryptografiÄ… symetrycznÄ… i asymetrycznÄ… oraz praktycznych aspektÃ³w bezpieczeÅ„stwa danych.

% =========================


\section{Podstawy matematyczne}
% (b)
% =========================

Podstawy matematyczne â€” Fundamenty dziaÅ‚ania RSA

Algorytm RSA opiera siÄ™ na kilku kluczowych pojÄ™ciach matematycznych: liczbach pierwszych, arytmetyce modularnej oraz funkcjach jednokierunkowych.

PodstawÄ… dziaÅ‚ania RSA jest wybÃ³r dwÃ³ch duÅ¼ych liczb pierwszych. Liczby te sÄ… nastÄ™pnie mnoÅ¼one, tworzÄ…c moduÅ‚ 
n, ktÃ³ry stanowi czÄ™Å›Ä‡ klucza publicznego i prywatnego. MnoÅ¼enie duÅ¼ych liczb pierwszych jest operacjÄ… obliczeniowo Å‚atwÄ…, natomiast rozkÅ‚ad ich iloczynu na czynniki pierwsze jest bardzo trudny dla odpowiednio duÅ¼ych wartoÅ›ci. BezpieczeÅ„stwo RSA wynika wÅ‚aÅ›nie z trudnoÅ›ci problemu faktoryzacji duÅ¼ych liczb.

Drugim istotnym elementem jest arytmetyka modularna, czyli wykonywanie dziaÅ‚aÅ„ z resztÄ… z dzielenia. ZarÃ³wno szyfrowanie, jak i odszyfrowanie w RSA polega na potÄ™gowaniu modulo n. Do efektywnego wykonywania takich obliczeÅ„ stosuje siÄ™ algorytmy szybkiego potÄ™gowania modularnego, ktÃ³re pozwalajÄ… pracowaÄ‡ na bardzo duÅ¼ych liczbach.

W procesie generowania kluczy wykorzystuje siÄ™ rÃ³wnieÅ¼ funkcjÄ™ Eulera ğœ‘(ğ‘›), ktÃ³ra okreÅ›la liczbÄ™ liczb wzglÄ™dnie pierwszych z 
n. Wybierany jest wykÅ‚adnik publiczny e, ktÃ³ry jest wzglÄ™dnie pierwszy z ğœ‘(ğ‘›), a nastÄ™pnie obliczany jest wykÅ‚adnik prywatny 
ğ‘‘ jako odwrotnoÅ›Ä‡ modularna liczby ğ‘’ modulo ğœ‘(ğ‘›).DziÄ™ki temu operacje szyfrowania i odszyfrowania sÄ… wzajemnie odwracalne.

RSA jest przykÅ‚adem funkcji jednokierunkowej z tzw. â€furtkÄ…â€ (trapdoor). Oznacza to, Å¼e Å‚atwo jest wykonaÄ‡ operacjÄ™ szyfrowania przy uÅ¼yciu klucza publicznego, natomiast odwrÃ³cenie jej bez znajomoÅ›ci klucza prywatnego jest obliczeniowo niepraktyczne.

RSA naleÅ¼y do kryptografii asymetrycznej â€” uÅ¼ywa dwÃ³ch rÃ³Å¼nych kluczy. W przeciwieÅ„stwie do niej kryptografia symetryczna (np. AES) wykorzystuje jeden wspÃ³lny klucz do szyfrowania i odszyfrowania. Szyfry symetryczne sÄ… znacznie szybsze, ale wymagajÄ… bezpiecznego sposobu przekazania klucza. W praktyce czÄ™sto stosuje siÄ™ systemy hybrydowe: RSA do wymiany klucza, a AES do szyfrowania danych.

NaleÅ¼y podkreÅ›liÄ‡, Å¼e bezpieczeÅ„stwo RSA opiera siÄ™ fundamentalnie na trudnoÅ›ci faktoryzacji duÅ¼ych liczb â€” jest to podstawowe zaÅ‚oÅ¼enie bezpieczeÅ„stwa tego algorytmu.

% =========================


\section{Projekt i implementacja}
% (c)
% =========================

W ramach projektu zaimplementowano system bezpiecznej komunikacji oparty na kryptosystemie klucza publicznego RSA. System zostaÅ‚ zaprojektowany w sposÃ³b modularny, oddzielajÄ…c warstwÄ™ matematyczno--kryptograficznÄ… od warstwy demonstracyjnej i testowej. Implementacja obejmuje generowanie kluczy RSA, szyfrowanie i deszyfrowanie danych, testowanie poprawnoÅ›ci algorytmÃ³w oraz prosty protokÃ³Å‚ komunikacji symulujÄ…cy bezpiecznÄ… wymianÄ™ wiadomoÅ›ci.

Generowanie kluczy RSA polega na losowaniu dwÃ³ch duÅ¼ych liczb pierwszych o dÅ‚ugoÅ›ci 1024 bitÃ³w. Do sprawdzania ich pierwszoÅ›ci zastosowano probabilistyczny test Millera--Rabina, ktÃ³ry zapewnia wysokie prawdopodobieÅ„stwo poprawnoÅ›ci przy akceptowalnym czasie obliczeÅ„. NastÄ™pnie obliczany jest moduÅ‚
\( n = p \cdot q \) oraz funkcja Eulera
\( \varphi(n) = (p - 1)(q - 1) \).
WykÅ‚adnik publiczny \( e \) wybierany jest jako standardowa wartoÅ›Ä‡ 65537, natomiast wykÅ‚adnik prywatny \( d \) wyznaczany jest przy uÅ¼yciu rozszerzonego algorytmu Euklidesa poprzez obliczenie odwrotnoÅ›ci modularnej.

Szyfrowanie i deszyfrowanie danych realizowane sÄ… zgodnie z definicjÄ… algorytmu RSA. Do obliczeÅ„ potÄ™g modularnych wykorzystano algorytm szybkiego potÄ™gowania (exponentiation by squaring), co znaczÄ…co zwiÄ™ksza wydajnoÅ›Ä‡ obliczeÅ„ dla duÅ¼ych wykÅ‚adnikÃ³w. Operacje arytmetyczne na duÅ¼ych liczbach caÅ‚kowitych realizowane sÄ… przy uÅ¼yciu biblioteki \texttt{\path{boost::multiprecision::cpp\_int}}.

W celu obsÅ‚ugi wiadomoÅ›ci tekstowych zastosowano uproszczony mechanizm kodowania polegajÄ…cy na zamianie znakÃ³w ASCII na wartoÅ›ci liczbowe. KaÅ¼dy znak szyfrowany jest osobno, co pozwala speÅ‚niÄ‡ warunek \( m < n \) bez stosowania zÅ‚oÅ¼onych schematÃ³w dopeÅ‚niania (paddingu).

Demonstracyjny protokÃ³Å‚ bezpiecznej komunikacji zostaÅ‚ zaimplementowany w pliku
\texttt{\path{secure_demo.cpp}}. Symuluje on wymianÄ™ wiadomoÅ›ci pomiÄ™dzy nadawcÄ… i odbiorcÄ… poprzez generowanie kluczy, publikacjÄ™ klucza publicznego, szyfrowanie wiadomoÅ›ci, zapis szyfrogramu do pliku oraz jego odszyfrowanie po stronie odbiorcy.

\subsection*{Pseudocode: RSA Key Generation}
\begin{verbatim}
Algorithm RSA-Key-Generation
Input: key length
Output: public key (e, n), private key (d, n)

1. Generate two large random primes p and q
2. Compute n = p * q
3. Compute phi(n) = (p - 1)(q - 1)
4. Choose e such that gcd(e, phi(n)) = 1
5. Compute d = e^(-1) mod phi(n)
6. Return (e, n) and (d, n)
\end{verbatim}

\subsection*{Pseudocode: RSA Encryption}
\begin{verbatim}
Algorithm RSA-Encrypt
Input: message m, public key (e, n)
Output: ciphertext c

1. Ensure m < n
2. Compute c = m^e mod n
3. Return c
\end{verbatim}

\subsection*{Pseudocode: RSA Decryption}
\begin{verbatim}
Algorithm RSA-Decrypt
Input: ciphertext c, private key (d, n)
Output: message m

1. Compute m = c^d mod n
2. Return m
\end{verbatim}

\subsection*{Pseudocode: Secure Communication Protocol}
\begin{verbatim}
Algorithm Secure-Communication
1. Receiver generates RSA key pair
2. Receiver publishes public key (e, n)
3. Sender encrypts message using public key
4. Ciphertext is transmitted over public channel
5. Receiver decrypts message using private key
\end{verbatim}

% =========================
\section{Wyniki}
% (d)
% =========================

PoprawnoÅ›Ä‡ implementacji zostaÅ‚a zweryfikowana przy uÅ¼yciu testÃ³w matematycznych oraz testÃ³w funkcjonalnych. Rozszerzony algorytm Euklidesa zostaÅ‚ przetestowany na duÅ¼ej liczbie losowych par liczb, co potwierdziÅ‚o poprawnoÅ›Ä‡ obliczeÅ„ najwiÄ™kszego wspÃ³lnego dzielnika oraz speÅ‚nienie toÅ¼samoÅ›ci BÃ©zouta.

DziaÅ‚anie kryptosystemu RSA sprawdzono poprzez szyfrowanie i deszyfrowanie wiadomoÅ›ci tekstowych. Odszyfrowana wiadomoÅ›Ä‡ byÅ‚a identyczna z wiadomoÅ›ciÄ… oryginalnÄ…, co potwierdza poprawnoÅ›Ä‡ implementacji algorytmu RSA. Najbardziej czasochÅ‚onnym etapem dziaÅ‚ania systemu jest generowanie kluczy, natomiast szyfrowanie i deszyfrowanie krÃ³tkich wiadomoÅ›ci przebiega wystarczajÄ…co szybko dla celÃ³w demonstracyjnych. Ograniczeniem rozwiÄ…zania jest brak obsÅ‚ugi duÅ¼ych iloÅ›ci danych.

\subsection*{PrzykÅ‚ad dziaÅ‚ania systemu}

PoprawnoÅ›Ä‡ dziaÅ‚ania systemu zostaÅ‚a rÃ³wnieÅ¼ zweryfikowana na podstawie
rzeczywistego uruchomienia programu demonstracyjnego
(\texttt{secure\_demo.cpp}). PoniÅ¼ej przedstawiono przykÅ‚adowy wynik
uzyskany podczas testu systemu.

\begin{itemize}
\item \textbf{WiadomoÅ›Ä‡ jawna (plaintext):} HELLO
\item \textbf{WiadomoÅ›Ä‡ po odszyfrowaniu (decrypted plaintext):} HELLO
\end{itemize}

Podczas szyfrowania kaÅ¼dy znak wiadomoÅ›ci zostaÅ‚ zaszyfrowany osobno
przy uÅ¼yciu algorytmu RSA. Wygenerowany szyfrogram stanowiÅ‚ ciÄ…g duÅ¼ych
liczb caÅ‚kowitych, zapisanych do pliku \texttt{cipher.txt}. Fragment
rzeczywistego szyfrogramu przedstawiono poniÅ¼ej:

\begin{verbatim}
14432898923990352452009045344983720966622271983973591131000170864005536...
10343580874497184732684271618570625033912501502479511875915177614092409...
20038361361298919327328562897599194252421215161097741995486639385839009...
\end{verbatim}

Odszyfrowana wiadomoÅ›Ä‡ jest identyczna z wiadomoÅ›ciÄ… oryginalnÄ…, co
jednoznacznie potwierdza poprawnoÅ›Ä‡ implementacji algorytmu RSA oraz
zastosowanego protokoÅ‚u bezpiecznej komunikacji.

% =========================
\section{Analiza bezpieczeÅ„stwa}
% (e)
% =========================

BezpieczeÅ„stwo kryptosystemu RSA opiera siÄ™ na trudnoÅ›ci faktoryzacji duÅ¼ych liczb zÅ‚oÅ¼onych. Przy zastosowanej dÅ‚ugoÅ›ci klucza 1024 bity system speÅ‚nia cele demonstracyjne projektu, jednak w rzeczywistych zastosowaniach zalecane sÄ… obecnie dÅ‚uÅ¼sze klucze.

Implementacja ma charakter edukacyjny i zawiera uproszczenia. Kodowanie wiadomoÅ›ci odbywa siÄ™ bez uÅ¼ycia formalnych schematÃ³w dopeÅ‚niania, takich jak PKCS\#1, ktÃ³re w realnych systemach kryptograficznych sÄ… niezbÄ™dne do ochrony przed atakami opartymi na strukturze danych. Dodatkowo klucze kryptograficzne zapisywane sÄ… do plikÃ³w tekstowych, co w praktycznych zastosowaniach stanowiÅ‚oby istotne zagroÅ¼enie bezpieczeÅ„stwa.

W rzeczywistych systemach RSA wykorzystywane jest zazwyczaj wyÅ‚Ä…cznie do bezpiecznej wymiany kluczy, natomiast dane szyfrowane sÄ… przy uÅ¼yciu algorytmÃ³w symetrycznych, takich jak AES. Takie podejÅ›cie, znane jako szyfrowanie hybrydowe, znaczÄ…co poprawia wydajnoÅ›Ä‡ i bezpieczeÅ„stwo systemu.

% =========================
\section{Podsumowanie}

% (f)
% =========================
Podsumowanie â€” Wnioski i moÅ¼liwe rozszerzenia

Projekt pozwoliÅ‚ na praktyczne poznanie dziaÅ‚ania kryptosystemu RSA oraz zrozumienie matematycznych podstaw kryptografii asymetrycznej. Podczas realizacji zaimplementowano generowanie kluczy, szyfrowanie i odszyfrowanie wiadomoÅ›ci, co umoÅ¼liwiÅ‚o przeÅ‚oÅ¼enie teorii na dziaÅ‚ajÄ…cy system.

W trakcie pracy wykorzystano pojÄ™cia takie jak liczby pierwsze, arytmetyka modularna, odwrotnoÅ›Ä‡ modularna oraz szybkie potÄ™gowanie. Projekt pokazaÅ‚ rÃ³wnieÅ¼, jak istotne sÄ… parametry bezpieczeÅ„stwa, w szczegÃ³lnoÅ›ci dÅ‚ugoÅ›Ä‡ klucza oraz jakoÅ›Ä‡ generowanych liczb losowych.

MoÅ¼liwe przyszÅ‚e rozszerzenia projektu obejmujÄ… zastosowanie wiÄ™kszych dÅ‚ugoÅ›ci kluczy, co zwiÄ™kszyÅ‚oby poziom bezpieczeÅ„stwa systemu. Kolejnym krokiem mogÅ‚aby byÄ‡ implementacja podpisÃ³w cyfrowych z uÅ¼yciem RSA, co pozwoliÅ‚oby zapewniÄ‡ nie tylko poufnoÅ›Ä‡, ale takÅ¼e autentycznoÅ›Ä‡ i integralnoÅ›Ä‡ danych.

System moÅ¼na rÃ³wnieÅ¼ rozbudowaÄ‡ do postaci kryptosystemu hybrydowego, w ktÃ³rym RSA sÅ‚uÅ¼y do bezpiecznej wymiany klucza symetrycznego, a wÅ‚aÅ›ciwe dane szyfrowane sÄ… szybkim algorytmem symetrycznym, takim jak AES. Dodatkowo moÅ¼na dodaÄ‡ mechanizmy paddingu (np. OAEP), bezpieczne generatory liczb losowych oraz optymalizacje wydajnoÅ›ciowe.

Takie rozszerzenia przybliÅ¼yÅ‚yby projekt do rozwiÄ…zaÅ„ stosowanych w rzeczywistych systemach kryptograficznych.
% =========================

\end{document}
